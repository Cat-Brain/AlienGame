#version 330 core
out vec4 FragColor;

in vec3 normal;
in vec3 fragPos;
in vec3 boundingPos;

uniform vec3 playerPos;
uniform vec3 pos;
uniform float scale;
uniform sampler3D voxels;

vec4 Opacity(vec4 a, vec4 b)
{
    return vec4(a.a * a.rgb + (1 - a.a) * b.rgb, a.a + (1 - a.a) * b.a);
}

void main()
{
    vec3 moveDir = normalize(fragPos - playerPos);

    vec3 currentPos = /*1 - */boundingPos * scale;
    vec3 rPlayerPos = (playerPos - pos) / scale + 0.5;
    if(rPlayerPos.x > 0.0 && rPlayerPos.x < 1.0 &&
        rPlayerPos.y > 0.0 && rPlayerPos.y < 1.0 &&
        rPlayerPos.z > 0.0 && rPlayerPos.z < 1.0)
        currentPos = rPlayerPos * scale;
    vec3 currentVoxelPos = floor(currentPos + normal * 0.5);
    
    float dX = 1.0 / max(0.0001, abs(moveDir.x));
    float dY = 1.0 / max(0.0001, abs(moveDir.y));
    float dZ = 1.0 / max(0.0001, abs(moveDir.z));
/*
    vec2 step;
    vec2 sideDist;
    
    if (moveDir.x < 0)
    {
        step.x = -1;
        sideDist.x = (posX - mapX) * deltaDistX;
    }
    else
    {
        step.x = 1;
        sideDist.x = (mapX + 1.0 - posX) * deltaDistX;
    }
    if (moveDir.y < 0)
    {
        step.y = -1;
        sideDist.y = (currentPos.y - mapY) * deltaDistY;
    }
    else
    {
        step.y = 1;
        sideDist.y = (currentPos.y + 1.0 - posY) * deltaDistY;
    }*/
    vec4 color = texture3D(voxels, currentVoxelPos / scale);
    for(int i = 0; i < 1; i++)
    {
        float cDX = (floor(currentPos.x) - currentPos.x) * dX;
        float cDY = (floor(currentPos.y) - currentPos.y) * dY;
        float cDZ = (floor(currentPos.z) - currentPos.z) * dZ;

        if(cDX > cDY)
        {
            if(cDY > cDZ)
            {
                currentPos += moveDir * cDZ;
                currentVoxelPos.z += sign(moveDir.z);
            }
            else
            {
                currentPos += moveDir * cDY;
                currentVoxelPos.y += sign(moveDir.y);
            }
        }
        else
        {
            if(cDX > cDZ)
            {
                currentPos += moveDir * cDZ;
                currentVoxelPos.z += sign(moveDir.z);
            }
            else
            {
                currentPos += moveDir * cDX;
                currentVoxelPos.x += sign(moveDir.x);
            }
        }

        if(currentVoxelPos.x > scale || currentVoxelPos.x < 0 ||
            currentVoxelPos.y > scale || currentVoxelPos.y < 0 ||
            currentVoxelPos.z > scale || currentVoxelPos.z < 0)
            break;
        vec4 newColor = texture3D(voxels, currentVoxelPos / scale);
        if(newColor.a > 0.5)
        {
            color = newColor;
            color.a = 1.0;
            break;
        }
    }
    if(color.a > 0.5)
        FragColor = color;
    else
        discard;
    //FragColor = Opacity(color, vec4(0.0, 0.0, 0.0, 1.0));
    FragColor = vec4(vec3(1 / (length(currentPos - boundingPos * scale) + 1)), 1.0);
}